pdf 1 - Intro

slide 21
Un calcolatore per essere sicuro deve essere sicuro sia a livello hardware che a livello software.
In questo corso ci si focalizza principalmente sulla "sicurezza dei dati", che consiste nel garantire i seguenti requisiti fondamentali:
- confidenzialità;
- integrità;
- disponibilità;
- autenticazione;
- non ripudio.

Quando parliamo di sicurezza dei dati, in questo corso, faremo un'assunzione fondamentale: assumeremo che il nostro hardware, firmware e sistema operativo, siano SICURI.
Ovviamente questa ipotesi non è sempre verificata, ma in questo corso (quando studieremo i servizi e meccanismi di sicurezza) lo daremo per scontato.

NB: la sicurezza HW e FW non è argomento proprio del corso, ma la prof ci ha dato qualche info a riguardo per sapere giusto di cosa stiamo parlando.

Sicurezza HW
Soprattutto negli ultimi anni, la sicurezza hardware sta emergendo in maniera preponderante, perché sempre di più si sono scoperte vulnerabilità a livello di componenti fisici (in particolare memorie, periferiche, I/O e linee di trasmissione).
L'ambito della sicurezza hardware si occupa di proteggere il calcolatore, ma anche altri dispositivi fisici, appunto, da minacce quali furto, danneggiamento o alterazione dei componenti.

Sicurezza FW
Così come l'hardware, anche il firmware dev'essere sicuro: ci sono infatti diverse vulnerabilità legate al FW, specialmente recenti (anche in questo caso ci troviamo in un'area in grande espansione, soprattutto nell'ultimo periodo).
Esistono diversi meccanismi di analisi del firmware, che si dividono in statici e dinamici, e che permettono, appunto, di verificare che il firmware si comporti correttamente.
Il motivo per cui è importante anche la sicurezza del firmware, è dato dal fatto che, partendo dal livello applicativo, per garantirne l'autenticità (ovvero che sia stato sviluppato effettivamente dall'azienda o produttore che l'ha rilasciato) e che non sia stato compromesso (ovvero che non abbia subito modifiche, quali ad esempio iniezione di software malevolo, e quindi che funzioni correttamente), c'è una specie di catena di sicurezza:
1) per verificare la correttezza dell'applicativo esistono ad esempio dei software antimalware;
2) ma i software antimalware eseguono anch'essi a livello applicativo, e nessuno ci garantisce che l'ambiente di esecuzione (ovvero il Sistema Operativo) sia corretto;
3) prima ancora del Sistema Operativo esegue il bootloader, che esegue dei controlli di verifica per garantire l'affidabilità del SO;
4) a loro volta i bootloader potrebbero essere compromessi, dunque serve ancora qualcosa che ci garantisca che la fase di bootloading sia avvenuta con successo.

Meccanismi per garantire la corretta esecuzione del bootloading: trusted boot e secure boot

Trusted boot
Tutta la fase di inizializzazione è avvenuta usando piattaforme trusted (che fanno utilizzo di componenti -processori- ad hoc, anche crittografici, che conservano delle chiavi tramite le quali possiamo verificare che il firmware venga eseguito correttamente.

Secure boot


Per garantire che la fase di booting sia avvenuta con successo (trusted boot oppure secure boot)

Non sono oggetto del corso ma ce le dice per darci cenni di base (noi daremo questo per scontato)

trusted boot: tutta la fase di iniz. è avvenuta usando piattaforme trusted (che fanno utilizzo di componenti -processori- ad hoc anche crittografici, che conservano delle chiavi tramite le quali possiamo verificare che tutti i componenti (firmware) vengano eseguiti correttamente

secure boot: faccia utilizzo di un'interfaccia standard che garantisce più a livello software che tutto avvenga in maniera corretta.

quello che possiamo dire è che grandi aziende quali Intel, IBM, ecc.

tramite chip aggiuntivi e SO ad hoc, garantiscono che ttute le conf hw e sw siano avviate correttamente.
Questo garantisce una piattaforma fidata.

da una parte le grandi aziende che si sono riunite per fare qualcosa a livello hardware, mentre dall'altro è un approccio più software.


c'è una catena di sicurezza che dovrebbe essere rispettata

applicativi > SO > bootloading > hardware

trusted boot/secure boot

coprocessori dedicati e SO specifici (quindi soluzione hardware);
SO enhanced, estesi con funzionalità specifiche di sicurezza (qua però è tutto a livello software)

vogliamo garantire che l'accesso ad ogni risorsa, almeno a livello base, siano regolamentati

>>> Madonna Troia <<< (Sì)

è evidente che comunque la sicurezza



slide 22

quando installo dei componenti di sicurezza come faccio a sapere che quel componente sia sicuro? Ci dev'essere qualcuno che me lo garantisca.

ovviamente occorrono degli enti di certificazione e degli standard che definiscono delle metodologie con cui andare a verificare che un prodotto effettivamente sia sicuro.
Applicando questi standard gli enti ci garantiscono la sicurezza del prodotto che installiamo (ce ne sono citati alcuni).


terminologia

abbiamo già definito:
requisiti di sicurezza, confidenzialità, integritò, disponibilità, autenticità, non ripudio

andremo ad analizzare quali sono i meccanismi che ci permettono di rilevare/prevenire un attacco


attacco: azione mirante a compromettere una proprietà critica dell'informazione

d'ora in poi per analizzare estudiare i meccanismi di sicurezza faremo riferimento ad un modello molto specifico: modello del canale insicuro


Modello che ha senso ovviamente se ci occupiamo di sicurezza dei dati.
Questo modello prevede che ci sia una sorgente dei dati, destinazione a cui sono rivolti, e che ci sia un canale che mette in comunicaione sorgente con destinazione

assumiamo che:
-la sorgente abbia un HW e SO sicuro;
-che la destinazione abbia un ambiente sicuro;
-ma che il canale sia insicuro.

Ovvero: sul canale si possono inserire degli intrusori e possono fare degli attacchi passivi e attivi appunto sul canale.

Se questo è il nostro modello, ci chiediamo se la sorgente produce dei dati, che devono essere trasmessi sul canale insicuro, la destinazione consuma i dati;

dobbiamo garantire che la destinazione possa consumare correttametne ed interpretare correttamente quei dati.


se la sorgente produce dati con garanzia di autenticità, la destinazione deve poter verificare l'autenticità anche in seguito alla consumazione di tali (non ripudio).

Classificazione attacchi:
2 tipi: attacco passivo/attivo

passivo: l'intrusore si inserisce sul canale, ma l'unica cosa che può fare è intercettare i dati (li può osservare -io intrusore mi inserisco sul canale e monitoro i dati, ma non faccio alcuna azione che modifichi/alteri il flusso-)

Questo canale può essere un bus, un canale interno offline, ma ovviamente anche un canale diretto;


attivo: l'intrusore può accedere al canale ed alteraattivamente il normale flusso dei dati, in che modo? diversi:
-modificare il flusso intenzionalmente, per minare il contenuto dei dati (attacco all' "integrità");
-aggiungere informazioni (inserite dall'intrusore) - sto come fabbricando dei nuovi dati - la falsificazione secondo questo tipo mina l' "autenticità". Faccio credere alla destinazione che i dati da me prodotti siano prodotti dalla sorgente legittima;
-interrompere il normale flusso, impedendo che i dati arrivino alla destinazione (minaccia il requisito di "disponibilità".


slide 24
contromisure per attacchi passivi:
-preventive, prevengo la possibilità che un dato venga intercettato;
-rilevazione, che sia in corso;
-reazione, ad attacco avvenuto

Se i dati sono non confidenziali, a me non interessa nulla che i dati vengano intercettati


per proteggere riservatezza dei dati, ovviamente sarà necessaria prevenzione



nostro obbiettivo come ingegneri: capire a fronte di più possibilità progettuali quale ha più senso

Possibili soluzioni per attacchi passivi:
-impedire accesso al canale. È una soluzione sensata? È scalabile? È economicamente sostenibile? Impedire l'accesso significa che o ho dei canali dedicati, oppure metto in piedi meccanismi di controllo accesso su larga scala, che fa in modo che ogni volta che una sorgente accede al canale, il meccanismo chiede di autenticarsi. Questa soluzione non è economicamente sostenibile né scalabile.
-criptare i dati che vogliamo inviare (rendere incomprensibili i dati trasmessi, tranne il destinatario legittimo)



contromisure per attacchi attivi:

ha senso adottare una contromisura preventiva? Protegge contro attacchi ad autenticità, integrità, disponibilità? In linea di principio sì, ma come posso prevenire un attacco al flusso dei dati? Il flusso è in corso

unico modo è impedire l'accesso al canale, si può fare ma ovviamente ci sono sempre gli svantaggi specificati prima.

è necessaria una contromisura di rilevazione, per permettere alla destinazione se quel flusso di dati è corretto o no.

certificato di autenticità.

la rappresentazione dei dati non è incomprensibile, ma al normale flusso dei dati aggiungo dati in più che permettono alla destinazione di capire se il flusso è integro e autentico.

attestati di autenticità/integrità

ci sono meccanismi crittografici che permettono di ottenerli

VOGLIAMO
LA
PORCAMADONNA
DI
PAUSA
DIOPORCO REBECCA

(dio stronzo, dio mattone, dio sedia, dio tappeto, dio finestra, dio matita, dio orologio, dio serio, dio stupido, dio telegram, dio crittografato, dio telegrafato, dio barra spaziatrice, dio sistema operativo, dio linux, dio Marcello, gesù saponetta, gesù scivoloso, gesù rickroll, gesù sul lago duria, madonna donna, madonna sgravata, madonna asus, madonna erba, madonna pokèmon, madonna alta 1.70, madonna bruttissima, madonna ruggine, madonna grondaria sporca, madonna tubo di plastica, madonna scarico)


se il meccanismo lo colloco a livello applicativo è molto personalizzabile ma richiede manutenzione

trasporto è più trasparente alle applicazioni;

livello di rete è completamente trasparente, ma è meno personalizzabile rispetto alle esigenze delle applicazioni

a seconda del livello avrò prestazioni, personalizzabilità e trasparenza alle applicazioni diverse.


NUOVO PDF


passa pausa
pausa banda
pausa dioporco
dio maiuscolo


come facciamo a costruire degli attestati? Dandoti una testata xd

trasformazioni di sicurezza -> dobbiamo costruire degli algoritmi o protocolli (sequenza di azioni ordinate, che mi permettano di trasformare l'informazione orginaria in qualcos'altro (qualcosa di incomprensibile o qualcosa di ridondante che aggiunga alle informazioni gli attestati)

trasformazioni: algotirmi o protocolli

algoritmi =
prima trasformazione T1 (trasformazione dei dati prima di metterli sul canale insicuro)
seconda trasformazione T2 (per risalire al contenuto dei dati)

non sempre una singola trasformazione è sufficiente. per vari motivi: a volte c'è bisogno di un protocollo (serie di trasformazioni che sorgente e destinazione devono fare, perché noi nel modello di minaccia più semplice assumiamo che la sorgente si comporti bene e la destinazione si comportano bene, ma a volte potrebbero a loro volta essere compromesse o malintenzionate)

estremi in buona fede
mmh dimmi come fai a fare la fede che ti viene buona esagerata

vedremo vari protocolli:

alcuni richiedono l'intervento di una terza entità (oltre a sorgente/destinatario), che fa da arbitro/giudice

caratteristica di tutte queste trasformazioni: ridondanza in termini di codifica e di tempo

caratteristica comune alle trasformazioni per la sicurezza è la ridondanza.
È fondamentale. Perché impiegando più bit di rappresentazione, ha un overhead nel sistema, se non altro in termini di occupazione di banda, di memorizzazione del dato.


-crittografia studia come progettare le trasformazioni che mi permettono di proteggere le proprietà di sicurezza dell'informazione
-crittoanalisi studia roba che permette di rompere le proprietà di sicurezza dell'informazione


trasformazioni che non studiamo in questo corso, vanno studiate in termini di quanto tempo e quante risorse computazionali richiedono per rompere tali proprietà.

3 principi della difesa che guidano la progettazione delle trasformazioni:
-dev'essere impossbile sapere che trasformazione è stata eseguita;
-impossibile dedurre qual è la trasformazione adottata;
-dev'essere impossibile indovinare la trasformazione adottata.

Per ora parliamo di impossibilità, poi arriveremo alla difficoltà

se la trasformazione è segreta è chiaro che diventa impossibile dedurre e indovinare

devo far sì che il calcolo di sapere, dedurre o indovinare, sia impossibile.

difficili per chi conosce il segreto, impossibili per chi non lo conosce.




trasformazione diretta (di encryprion): prendo il mio dato in chiaro (plain text) in qualcosa di non comprensibile (cypher text)
trasformazione inversa (di decryption): prende dal canale il cypher text e lo trasforma in plain text

un intrusore si può intromettere, ma non riesce a capire quale sia il testo in chiaro


questa trasformazione è bidirezionale: uno cripta, l'altro decripta e viceversa.
Questo schema funziona se entrambi sono online/solo uno dei due? Questo schema va bene in tutte le situazioni (se ad esempio A è online e cripta e invia, ma B è offline, quando torna online lo decripta, easy pez)

i calcoli per mettere in chiaro un testo cifrato, senza conoscere la trasformazione di decription devono essere facili per chi conosce


confronto:
deve poter vedere se a quel dato corrisponde quel riassunto

se il confronto ha successo => la destinazione può dire che il dato ricevuto è integro.
Significa che sul canale, in qualche modo sono stati inviati entrambi (dati originali e riassunto) - in qualche modo l'intrusore può attaccare entrambe o solo una delle due -

di sicuro la destinazione deve riceverle entrambe e deve confrontarle.

Quali sono le caratteristiche.

Come otteniamo il riassunto:
esistono le funzioni hash (funzioni che dato un input producono un input molto più piccolo, un'impronta)

non ci vanno bene tutte le funzioni hash, ma abbiamo bisogno di una funzione che chiamiamo "crittograficamente sicura", ovvero con 2 caratteristiche fondamentali:
"facilità di esecuzione" e "comportamento da oracolo casuale".

Una funzione hash crittograficamente sicura è tale se il suo comportamento è apparentemente aleatorio.

se io fornisco in ingresso a tale funzione un emssaggio di cui non conosco ancora l'impronta, si riscrontra in uscita uno dei qualsiasi dei 2^n valori possibili dove n è il numero di bit dell'impronta.
se io do in input un messaggio di dimensione m, non so con quale probabilità avrò quell'impronta.
Non posso prevedere con certezza quale valore avrà in uscita.

Questa è una caratteristica fondamentale;

altra caratteristica necessaria:
resistenza alle collisioni, ovvero se una funzione hash è critt sicura, l'individuazione di due messaggi con la stessa impronta da parte di un intrusore dev'essere difficile

se ho 2^m valori di ingresso con m > n, ovviamente ci sono delle collisioni, è inevitabile, ma dev'essere difficile per un intrusore trovare quella coppia di messaggi con la stessa impronta.

funzioni hash impiegate soprattutto per rilevare i disturbi (check sum)




per ora non ci interessa di com'è fatta o qual è l'algoritmo che useremo, ma sappiamo che per costruire un certificato di autenticità abbiamo bisogno di una funzione hash con certe caratteristiche (definite in precedenza).



esempio:
(slide) attestazione ed accertamento dell'integrità

supponiamo che A metta sul canale insicuro -> un messaggio m, affiancato da H (funzione hash crittograficamente sicura), a partire da m è stata costruita H(m)
B deve prendere il messaggio ricevuto, applicargli la funzione hash, che conosce anche lui, e verificare che l'hash ricevuto coincida con quello ottenuto applicando a sua volta la funzione hash.
Se equivalgono è tutto ok (tutto trasmesso correttamente).

La destinazion è in grado di rilevare se il messaggio ha subito modifiche?

Mettiamoci nei panni dell'intrusore:
se l'intrusore conosce la funzione hash può mettere un nuovo messaggio con hash allegato



abbiamo quindi 2 tipi di trasformazioni: Encryption, Hash

possiamo anche combinarle

e se volessimo garantire la riservatezza e l'integrità dei dati


dio stupido signor scheda grafica NVIDIA, la smetta di consumare la grande Battery



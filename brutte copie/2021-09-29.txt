minimizzare i costi

scegliendo il compromesso più opportuno tra robustezza, costi e trasparenza(?)


oggi ragioniamo a livello di schemi

schemi di come combiniamo le trasformazioni


possibile protocollo che combinasse trasformazioni di encryption ed hash

messaggio cifrato affiancato da hash calcolato sul messaggio cifrato

c = E(p)||H(E(p)) testo cifrato trasmesso

riservatezza garantita;
integrità non garantita - perché se io affianco attestato di integrità al
dato, l'intrusore si trova due parti di messaggio (cifrato e hash su cifrato)



potenzialmente un attacco è eseguibile? Ha veramente successo? 
Dobbiamo capire se si può verificare in certe condizioni.





l'autore e chi ha inviato un messaggio sono due cose diverse
(autore e da chi proviene)



la destinazione deve verificare che il messaggio ricevuto dev'essere originato proprio da chi 
dichiara di averlo inviato


trasformazioni che facciamo per costruire l'attestato di autenticità

S: trasformazione di firma (Sign) ci permette di scrivere la prova di autenticità
facile da eseguire in un senso, difficile da eseguire (nessun'altro è in grado di produrre un attestato di autenticità C spacciandosi per la sorgente legittima)

il destinatario deve verificare l'autenticità di quell'attestato, tramite un'operazione di verificare (V)

se l'operazione di V ha avuto successo deve anche restituire il messaggio M originale


che caratteristiche devono avere queste trasformazioni, oltre ad essere facili o difficili da
eseguire

ricordiamo i due principi: trasformazioni segrete e calcoli impossibili

trasformazione segreta: in questo caso è l'operazione di Sign - nessun'altro oltre la sorgente
legittima deve conoscere quella trasformazione, altrimenti chiunque può produrre un messaggio spacciandolo per di proprietà della sorgente)

i calcoli per costruire un messaggio apparentemente autentico senza conoscere la trasformazione della sorgente devono essere difficili.

Non serve essere online (vale qualunque combinazione - A online, B offline, viceversa, ed entrambi online(?))

2 schemi alternativi per realizzare sign-verify:

1) firma digitale
usa le funzioni S e V. La sorgente A invia sul canale sicuro M || c

sul canale insicuro invio m || c
la funzione S viene applicata all'impronta di m

vantaggi di questo schema:
- efficienza - la funzione di Sign è una trasformazione ridondante

H(m) è un'impronta, quindi è più piccola

- non ripudio - la destinazione (nello schema precedente) ottiene c dal canale (che è qualcosa di non interpretabile direttamente).
In questo schema lascio la libertà applicativa di decidere cosa fare su quel messaggio m ricevuto.
Se verificare immediatamente l'autenticità, oppure farlo più avanti.


2) hash applicata al messaggio concatenato con un segreto S, condiviso tra sorgente e destinazione.

la sorgente prende tale segreto, lo concatena col messaggio

sul messaggio invia 

la destinazione: se assume che il m viene da A, userà il segreto per fare i controlli (prende m*



differenza: prima il segreto lo conosceva solo la sorgende, quindi solo lei poteva costruire il certificato di autenticità; qui lo conosce anche B.

cosa non si può garantire: A si possa assumere la paternità di quel messaggio (può solo dimostrare di averlo inviato) perché anche B può costruire un H(m||s)

è più efficiente perché non inserisce la trasformazione

non garantisce il supporto di non ripudio: entrambi A e B possono scriverlo.

utile perché lavoriamo anche in sistemi IoT, quindi potrebbero essere necessarie cose semplici, efficienti e che consentano di consumare poca batteria.



sono entrambi robusti (garantiscono la correttezza del certificato di autenticità)

primo lo uso se ho bisogno di sapere da chi proviene e di chi è

secondo se voglio solo la provenienza




potocollo per difesa di riservatezza ed autenticazione

sul canale insicuro viene inviato il testo cifrato

la sorgente crea il messaggio, costruisce il 

SSL adotta funzione Hash crittograficamente sicura col segreto per costruire il c. di autenticità
il client prende il messaggio, lo concatena al certificato e lo cifra.

SSL IPsec

SSL protocollo a livello di trasporto (crea socket sicure in cui i messaggi sono autenticati)


altro schema:
SSH permette di aprire shell remote sicure.
Si prende il messaggio, si cifra e si manda sul canale insicuro il cifrato concatenato con l'attestato di autenticità costruito sul messaggio.


chiediamoci sempre qual è sequenza in fase di invio e ordine in cui vengono eseguite le operazioni in invio e ricezione.

terzo schema (IPSec)
considerato + corretto: encrypt and mac:
prima cifro poi creao l'autenticatore

cifro e costruisco l'attestato di autenticità sul cifrato concatenato col segreto.

in fase di invio in IPSec: cifro e autentico;
in fase di ricezione: controllo attestato di autenticità e poi decifro.

Oltre alla robustezza, ragioniamo in termini di efficienza.

efficienza infase di ricezione:
chi riceve deve necessariamente autenticare e decifrare (non ha altro modo di recuperare il messaggio iniziale, deve per forza eseguire 2 trasformazioni)

in IPSec risparmio eventualmente una trasformazione. Se il cifrato ha subito delle modifiche, chi riceve verifica il certificato e se qualcosa è andato storto, si risparmia l'operazione di decifratura, ovvero non viene proprio fatta.

in fase di invio il costo è uguale, tanto bisogna fare entrambe le trasformazioni.



Anonimato/Identificazione
Altro requisito


anonimato: requisito opposto all'identificazione (non lo vedremo)

identificazione: scenari applicativi che necessariamente richiedono di identificare l'identità che sta partecipando ad un'interazione (o per farlo pagare o perché bisogna farlo accedere a certe risorse, perché in base alla persona può avere tipi di accesso diversi)

processo di identificazione è realtime che si riferisce ad un preciso istante di tempo

io posso sapere con certezza, chi è in quell'istante di tempo l'identità che sta chiedendo di essere identificata.


per sapere chi c'è dall'altra parte bisogna prolungare l'identificazione nel tempo.
L'identificazione fondamentalmente è in un istante temporale.

Ma dev'essere anche efficace: evitare il più possibile la possibilità di falsi positivi e negativi:

falso positivo: probabilità di scambiare un utente autenticato per uno che non lo è, ovvero un utente si autentica ma gli viene rifiutato comunque l'accesso. Causa inefficienza.
falso negativo: un impostore si spacci per un utente specifico (più importante). Porta a una rottura della robustezza.

io posso identificare un'entità in base a qualcosa che conosce (password, pin, key)

se assumiamo che l'entità sia l'unica a conoscere questo segreto, possiamo autenticarla così

oppure qualcosa che possiede (es: token, tessera, smart card);

o qualcosa che fa parte di lui (dati biometrici, comportamentali).

robustezza di un sistema di identificazione è tanto più robusto quanti più principi combina.



qualunque protocollo di identificazione prevede una fase iniziale di registrazione (l'identificando sceglierà una prova da dimostrare, ed il verificatore registrerà un termine di paragone);

poi fase di dichiarazione, interrogazione e dimostrazione.


la dimostrazione dev'essere facile per la persona che si vuole autenticare ed è effettivamente lei, ma difficile per un intrusore.

Minacce + tipiche: io posso replicare la prova di dimostrazione.

un intrusore può:
-dedurre o indovinare la prova di identità;
-rubare il dispositivo;
-replicare una prova di identità che ha viaggiato sul canale in una legittima transizione di identificazione


alcune trasformazioni, ad esempio la funzione hash, di cifratura, o di firma a cui corrisponde funzione di verifica, devono essere difficili da invertire.

Concetto di funzione unidirezionale (non la dimostriamo, la prendiamo per verificata)


due principali problemi di un algoritmo (ovviamente per scenari applicativi generali):
1) mi dicono che sia sicuro (ma se è segreto chi l'ha ispezionato/testato? Nessuno o comunque magari non abbastanza)
2) 


domanda: master key con cui viene cifrata una breve quantità di dati (flusso)

master key è principale e viene condivisa fuori banda, simmetrica e segreta.
Poi viene generata secondo regole previste per generazione sicura della chiave, una chiave di sessione (aleatoria) e viene cifrata con master key. Sul canale viaggia messaggio cifrato ed anche la chiave.

(bisogna predisporre la possibilità di distribuire all'altra entità quella chiave di sessione (generata dal mittente). Questa viene distribuita cifrandola con la master key.
Ed è possibile in modalità ECB perché di fatto si tratta di una chiave aleatoria che occuperà sicuramente un blocco di cifratura.)

Domanda effettiva: se un attaccante modifica cifrato della chiave?
La decifr restituirà una stringa di bit, è altamente improbabile che venga restituito un messaggio con significato. Noi non possiamo sapere se la roba restituita dalla funz di decifrazione sia sensata o no.

L'encryption garantisce solo la confidenz. se vogliamo anche integrità, dobbiamo aggiungerla.


Oggi vediamo che a seconda dell'implementazione di E (a seconda delle trasformazioni che effettua), potrebbe anche non garantire confidenzialità


NB: La prof chiede di studiare molto bene le modalità di cifratura, perché sono fondamentali.
Per lunedì dobbiamo saperle perché ci fa vedere esempi di attacchi che ci fanno capire perché l'impiego di queste modalità è fondamentale


il segreto precondiviso in maniera sicura a priori è un'ipotesi fondamentale che facciamo.
A partire da questo abbiamo 2 sottomodelli:

1) master key
2) centro di distr di chiavi.

La master key ha problema fond. legato a scalabilità: se ogni coppia deve condividere una master key, se N utenti => N^2 chiavi da distribuire. Va bene per sistema piccolo, non va più bene se il dominio da gestire scala molto.


slide 30
Introduciamo terza parte fidata che in qualche modo interviene in distr chiavi di sessione: in questo modello, le chiavi master key predistribuite sono N con N numero di utenti, in quanto ogni utente condivide a priori una master key con il centro di distribuzione.
Così facendo viene ridotto il problema di scalabilità. 

In questo modello alternativo, possiamo immaginare di costruire


Come costruiamo protocollo che implementa il KDC?

Noi ne vediamo uno (principalmente adottato) ma ne vedremo uno alternativo che commenteremo.

La cosa fondamentale da fare è: a fronte di ogni protocollo commentarlo in termini di robustezza, efficienza (overhead sulla rete) e carico computazionale, a carico delle entità coinvolte.
Questi sono i criteri che dobbiamo considerare


Primo protocollo che analizziamo: slide 31
T: entità fidata. A ha condiviso Ka con KDC, B ha condiviso Kb

Ka e Kb sono le master key (condivise in maniera totalmente sicure, quindi non sono state intercettate e sono impossibili da indovinare)

quando A deve comunicare con B, ovviamente ha bisogno di una chiave di sessione.
Chi la genera? 
Ovviamente KDC deve essere in grado di condividere le chiavi di sessioni.
KDC: quando gli arriva richiesta di chiave di sessione da una entità (es: A) genera la chaive, la distribuisce in modo sicuro ad A, che la può usare per comunicare con altra entità (es: B)

A: dichiara necessità a KDC di avere una chiave di sessione ("voglio comunicare econ B"); poi manda un RNA (Numero Random Imprevedibile) che serve come sfida ("sto veramente parlando con KDC di cui mi fido?"). => 2 messaggi
Questa prima parte di sfida è dimostrazione di identità;

KDC preleva la sfida. Cosa aveva fatto prima? Precondiviso le master key, che ovviamente saranno memorizzate da qualche parte (es: DataBase protetto super sicuro, con accesso garantito). Quando riceve la richiesta cosa fa? È compito di T generare la chiave di sessione.
Dunque ora deve: rispondere alla sfida dimostrando di essere T (è in grado di cifrare il numero random, con il segreto condiviso, ovvero la master key Ka nel caso di A), ha capito con cui vuole parlare (ovvero B) e distribuire k (chiave di sessione), che poi A dovrà distribuire a B per comunicarci in modo confidenziale.
Dunque gli dà k cifrata con master key condivisa con B.

A riceve tutto il messaggio. Lo decifra (RNA ok, quindi sfida OK), e ottiene la chiave di sessione.

Ora deve distribuirlo a B per dire "T mi ha generato qualcosa, se tu sei chi dici di essere, deciframi questa cosa, risali a k"

{iniziatore: A (avvia richiesta di chiave)
interlocutore con T: solo A (interagire con T).}

NB: Dobbiamo costruire dei protocolli che abbiano il minimo numero di messaggi, ma che siano quelli fondamentali/indispensabili.


Cosa può fare un attaccante?
Può modificare: se modifica modifica a caso (A riceverà un k che magari è modificato, ma k è presente in due punti, quindi l'attaccante non riesce a modificare entrambi, essendo aleatori; magari viene modificato pure B;)
Quindi i problemi di integrità ci preoccupano poco.

un attacco di replica:
potrebbe esserci un attacco con replica nella comunicazione 3.
NB: replicare è sempre possibile. Un attaccante può sempre prendere un messaggio e riproporlo in un'altra comunicazione (es: prenderlo in 2 e replicarlo in 3)

T non controlla lo stato (che Ra sia sempre diverso)
Ma cosa se ne fa? Niente perché T comunque genera una chiave di sessione diversa.
Ogni sessione prevede che T generi una chiave diversa.

Al punto 3 però è diverso: qui la replica potrebbe avere successo, nel caso in cui l'intrusore è risalito alla conoscenza di k (se per qualche motivo sia riuscito a conoscere un k usato in una sessione precedente) se vuole estrarre 

stiamo ipotizzando che intrusore acceda al canale sicuro,

e abbia anche avuto il culo di accedere ad una chiave di sessione usata tra A e B.

Modello di minaccia: intrusore conosce qualche bit della chiave, oppure vuole comunque indurre B a produrre più campioni di testo cifrato, rispetto a quelli che comunque produrrebbe in una comunicazione normale.

Se il protocollo si chiudesse al passo 3 sarebbe dunque non sicuro nel caso dell'attacco di replica.

Tuttavia esistono altri 2 passi (4 e 5)

B dev'essere sicuro che la chiave provenga da A;

Il passaggio 4 dimostra ad A che effettivamente la chiave k è stata ricevuta da B.

Se A è fidato, comunque bisogna garantire che B sia effettivamente B.
Bisogna anche garantire che se A non è fidato, non sia possibile effettuare un attacco di replica.

Il messaggio 4 dice se è effettivamente sia e sia in grado di decifrare. Dunque manda un numero random Rb, che se B è in grado di decifrare, siamo sicuri che sia l'entità giusta e autentica.

Il protocollo ovviamente ha successo se si chiude completamente
Se a seguito del processamento del messaggio 5, 

il caso eccezionale in cui si conosca tutto k, ovviamente si possono rifare tutte queste operazioni (si induce B a usare k) ma anch'io che conosco k, posso fare il passo 5.


come si può evitare la conoscenza di k? B deve teneretraccia di quali sono le chiavi di sessione già utilizzate (è costoso, ma è l'unico rimedio per proteggere anche in quello scenario più sfortunato)

NB: il protocollo proposto, non prevede questa cosa, ma sarebbe una aggiunta.
L'attacco con replica è evitato tranne il caso in cui k è conosciuta interamente. In questo caso è necessario aggiungere un rimedio.

È chiaro che k essendo chiave di sessione deve avere una vita limitata. Ovvero il flusso di dati non deve durare "troppo tempo"
La chiave master key invece deve avere vita molto più lunga.

Problemi: il protocollo visto dobbiamo tenerlo a mente

il protocollo è stato usato in servizi di distribuzione di chiavi, intese come chiavi di sessione per comunicare.


overhead amministrativo:
bisogna installare servizio in più, gestirlo (memoria sicura in modo che master key non vengano prelevate); fare in modo che sia sempre disponibile e deve garantire scalabilità.

in reti di calcolatori, quando ho problema di scalabilità cosa viene adottato? Principio di partizionamento(?)
Se ho tantissimi utenti, li suddivido in domini di amministrazione (ogni KDC gestirà un dominio, ma farò in modo che questi possano comunicare)









esercizio:

scelgo un cifrario a blocco (es alg + robusto del mondo)
supponiamo di avere chiavi da 128
supponiamo che Ra sia 128, A sia 128, Rb sia 128, B sia 128, k sia 128 bit

abbiamo cifrario a blocco


ipotizziamo che chiavi siano non deduc non cracc

AES
dobbiamo scegliere modalità di impiego

ECB:
cifrato a blocchi.


CBC:
dipendenza da precedenti




Per AES si potrebbe raccolti i diversi messaggi delle varie comunicazioni (passo da 1 a 5) e accumulati per fare analisi sul testo cifrato.


Supponendo di avere la master key di A, intercettiamo la sfida (comunicazione 1 tra i due endpoint A e T) e appendiamo usando la chiave pubblica di A un valore arbitrario di sessione (ne scegliamo una che conosciamo solo noi, e la cifriamo, che verrà usata per comunicare con B

---
ECB, facciamo riferimento a comunicazione A-T
supponiamo di aver ottenuto il cifrato di una chiave di sessione vecchia, già usata fra A e B per comunicare.
Si potrebbe mettere in comunicazione A con C, facendogli credere di star comunicando con B.
Eka (Ra || B || k(C) || Ekc (A || k(C) ))
Il messaggio diventa decifrabile da C
---


supponiamo di usare ECB ad esempio nella seconda comunicazione.
Se tutti i pezzi (Ra, A, k, Rb, B) sono da 128 bit, quindi sappiamo la lunghezza,
supponendo di aver ottenuto una chiave di sessione vecchia usata per comunicare con B, potremmo

.............

un attaccante agendo sulla modalità di cifratura riesce comunque a sfruttare delle vulnerabilità. Poi l'attacco ha successo se il protocollo lo permette.

Session hijacking.
inserirsi all'interno di una sessione è difficile. Richiede anche di configurare il tutto in maniera diversa.


esercizio per casa:
abbiamo scartato ECB.
Analizzare CBC e le altre.
Cerchiamo di fare da soli i ragionamenti sull'overhead che ogni modalità può introdurre.
A nostro avviso quale può essere la modalità più efficiente (es occupazione banda sulla rete), propagazione degli errori, ecc.